// University of Illinois/NCSA
// Open Source License
// 
// Copyright (c) 2013, Advanced Micro Devices, Inc.
// All rights reserved.
// 
// Developed by:
// 
//     HSA Team
// 
//     Advanced Micro Devices, Inc
// 
//     www.amd.com
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal with
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimers.
// 
//     * Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimers in the
//       documentation and/or other materials provided with the distribution.
// 
//     * Neither the names of the LLVM Team, University of Illinois at
//       Urbana-Champaign, nor the names of its contributors may be used to
//       endorse or promote products derived from this Software without specific
//       prior written permission.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
// SOFTWARE.
/*!re2c

    re2c:define:YYCTYPE  = "char";
    re2c:define:YYCURSOR = curPos;
    re2c:define:YYLIMIT  = m_end;
    re2c:define:YYMARKER = marker;
    re2c:yyfill:enable   = 1;
    re2c:yych:conversion = 0;

    SPACE = [ \t];
    NL    = "\r"? "\n";
    ANY   = [^];

    WORD  = [a-zA-Z][a-zA-Z0-9]*;
    ID    = [a-zA-Z_][a-zA-Z0-9_]*;

    DCD   = [0-9];
    HXD   = [0-9a-fA-F];

    DECIMAL = "0" | [1-9]DCD*;
    OCTAL   = "0"[0-7]+;
    HEX     = "0"[xX]HXD+;

    INTEGER = DECIMAL|OCTAL|HEX;

    HLFHEX  = "0"[hH]HXD{4};
    SGLHEX  = "0"[fF]HXD{8};
    DBLHEX  = "0"[dD]HXD{16};

    EXP = [Ee][+-]?DCD+;
    FLOAT1 = DCD+  "."  DCD*   EXP?;
    FLOAT2 =       "."  DCD+   EXP?;
    FLOAT3 = DCD+ ("."  DCD*)? EXP;
    FLOAT = [+-]? (FLOAT1|FLOAT2|FLOAT3);

    C99FLT  = [+-]?"0"[xX]HXD+("."HXD*)?[pP][+-]?DCD+;
*/

#define YYFILL(n) { readChars(n); }

#include <strstream>

namespace HSAIL_ASM
{

void Scanner::readSingleStringLiteral(Token &t, std::string& outString)
{
    using namespace std;
    const char * &curPos = t.m_text.end;
    while(true) {
        const char *const prevPos = curPos;
        const char *marker;

/*!re2c
    re2c:indent:string = "        ";

    "\\" [0-7]{1,3}       {
        unsigned int v;
        SRef const s(prevPos+1,curPos);
        istrstream is(s.begin,s.length());
        is >> oct >> v;
        if (is.fail() || v>std::numeric_limits<unsigned char>::max()) {
            syntaxError(curPos, "Invalid character code");
        }
        outString.push_back(static_cast<unsigned char>(v));
        continue;
    }
    "\\" [xX][0-9A-Fa-f]{1,2} {
        unsigned int v;
        SRef const s(prevPos+2,curPos);
        istrstream is(s.begin,s.length());
        is >> hex >> v;
        if (is.fail() || v>std::numeric_limits<unsigned char>::max()) {
            syntaxError(curPos, "Invalid character code");
        }
        outString.push_back(static_cast<unsigned char>(v));
        continue;
    }
    "\\\\"         { outString.push_back('\134'); continue; }
    "\\'"          { outString.push_back('\047'); continue; }
    "\\\""         { outString.push_back('\042'); continue; }
    "\\?"          { outString.push_back('\077'); continue; }
    "\\a"          { outString.push_back('\007'); continue; }
    "\\b"          { outString.push_back('\010'); continue; }
    "\\f"          { outString.push_back('\006'); continue; }
    "\\n"          { outString.push_back('\012'); continue; }
    "\\r"          { outString.push_back('\015'); continue; }
    "\\t"          { outString.push_back('\011'); continue; }
    "\\v"          { outString.push_back('\013'); continue; }
    "\""           { curPos = prevPos; break; }
    "\\"           { syntaxError(curPos, "Invalid escape sequence"); }
    [\r\n]         { syntaxError(prevPos, "Runaway string literal"); }
    [^\r\n\\\"]+   { outString.insert(outString.end(), prevPos, curPos); continue; }
*/
    }
}

ETokens Scanner::scanModifier(EScanContext ctx, Scanner::Token &t)
{
    const char* &curPos = t.m_text.end;
    int &brigId = t.m_brigId;
    const char *marker = NULL;
/*!re2c
    re2c:indent:string = "    ";

@print $scanner{_mods_}

    "_1d"        { brigId = Brig::BRIG_GEOMETRY_1D;  return EMGeom; }
    "_1db"       { brigId = Brig::BRIG_GEOMETRY_1DB; return EMGeom; }
    "_1da"       { brigId = Brig::BRIG_GEOMETRY_1DA; return EMGeom; }
    "_3d"        { brigId = Brig::BRIG_GEOMETRY_3D;  return EMGeom; }
    "_2d"        { brigId = Brig::BRIG_GEOMETRY_2D;  return EMGeom; }
    "_2da"       { brigId = Brig::BRIG_GEOMETRY_2DA; return EMGeom; }
    "_2ddepth"   { brigId = Brig::BRIG_GEOMETRY_2DDEPTH; return EMGeom; }
    "_2dadepth"  { brigId = Brig::BRIG_GEOMETRY_2DADEPTH; return EMGeom; }

    "_height"       { brigId = Brig::BRIG_IMAGE_QUERY_HEIGHT;       return EMImageQuery; }
    "_depth"        { brigId = Brig::BRIG_IMAGE_QUERY_DEPTH;        return EMImageQuery; }
    "_array"        { brigId = Brig::BRIG_IMAGE_QUERY_ARRAY;        return EMImageQuery; }
    "_channelorder" { brigId = Brig::BRIG_IMAGE_QUERY_CHANNELORDER; return EMImageQuery; }
    "_channeltype"  { brigId = Brig::BRIG_IMAGE_QUERY_CHANNELTYPE;  return EMImageQuery; }
    "_width"        { switch(ctx) {
                      case EInstModifierInstQueryContext: brigId = Brig::BRIG_IMAGE_QUERY_WIDTH; return EMImageQuery; 
                      default:                            brigId = 0;                            return EMWidth;
                      } 
                    }
    "_align"     { brigId = 0; return EMAlign;  }
    "_v2"        { brigId = 2; return EMVector; }
    "_v3"        { brigId = 3; return EMVector; }
    "_v4"        { brigId = 4; return EMVector; }
    "_equiv"     { brigId = 0; return EMEquiv;  }
    "_ftz"       { brigId = 0; return EMFTZ;    }
    "_region"    { brigId = Brig::BRIG_SEGMENT_EXTSPACE0; return EMSegment; }
    "_const"     { brigId = Brig::BRIG_MEMORY_CONST;      return EMConst;   }
    "_nonull"    { brigId = Brig::BRIG_SEG_CVT_NONULL;    return EMNoNull;  }

    ""           { brigId = 0; return EMNone; }
*/

// "_" WORD     {  brigId = 0; return EMSkip; } /* TBD just to skip unknown modifiers, remove */
}

void Scanner::scanEmbeddedText(Scanner::Token &t)
{
    const char* &curPos = t.m_text.end;
    while(true) {
        const char *const prevPos = curPos;
/*!re2c
        re2c:indent:string = "        ";
        NL       { nextLine(curPos);
                   continue; }
        "#" ">"  { break; }
        "\000"   { curPos = prevPos; syntaxError(curPos, "Premature end of embedded text"); }
        ANY      { continue; }
*/
    };
}

ETokens Scanner::scanDefault(EScanContext ctx, Scanner::Token &t)
{
    const char* &curPos = t.m_text.end;
    int &brigId = t.m_brigId;
    const char *marker = NULL;
/*!re2c
    re2c:indent:string  = "        ";

    "<" "#"              { scanEmbeddedText(t); return EEmbeddedText; }
    "{"                  { return ELCurl;  }
    "}"                  { return ERCurl;  }
    "("                  { return ELParen; }
    ")"                  { return ERParen; }
    "["                  { return ELBrace; }
    "]"                  { return ERBrace; }
    "<"                  { return ELAngle; }
    ">"                  { return ERAngle; }
    "."                  { return EDot;    }
    ","                  { return EComma;  }
    ";"                  { return ESemi;   }
    ":"                  { return EColon;  }
    "+"                  { return EPlus;   }
    "-"                  { return EMinus;  }
    "="                  { return EEqual;  }
    "\""                 { return EQuot;   }

    "version"            { return EKWVersion; }
    "kernel"             { return EKWKernel; }
    "function"           { return EKWFunction; }
    "pragma"             { return EKWPragma; }
    "section"            { return EKWSection; }
    "rti"                { return EKWRTI; }
    "loc"                { return EKWLoc; }
    "extension"          { return EKWExtension; }
    "labeltargets"       { return EKWLabelTargets; }
    "signature"          { return EKWSignature; }
    "all"                { return EKWWidthAll;  }
    "fbarrier"           { return EKWFbarrier; }
    "width"              { return EKWImageWidth; }
    "height"             { return EKWImageHeight; }
    "depth"              { switch(ctx) {
                           case EImageOrderContext: brigId = Brig::BRIG_CHANNEL_ORDER_DEPTH; return EImageOrder; 
                           default: return EKWImageDepth;
                           } }
    "channel_type"       { return EKWImageChannelType; }
    "channel_order"      { return EKWImageChannelOrder; }
    "geometry"           { return EKWImageGeometry; }
    "array"              { return EKWImageArray; }
    "addressing"         { return EKWSamplerAddressing; }
    "coord"              { return EKWSamplerCoord; }
    "filter"             { return EKWSamplerFilter; }
    "align"              { return EKWAlign; }
    "const"              { return EKWConst; }
    "block"              { return EKWBlockStart; }
    "blocknumeric"       { return EKWBlockNum; }
    "blockstring"        { return EKWBlockStr; }
    "endblock"           { return EKWBlockEnd; }
    "fbar"               { return EKWFBar; }

    "WAVESIZE"           { return EWaveSizeMacro; }

    "nearest"            { brigId = Brig::BRIG_FILTER_NEAREST;    return ESamplerFilter; }
    "linear"             { brigId = Brig::BRIG_FILTER_LINEAR;     return ESamplerFilter; }

    "global"             { brigId = Brig::BRIG_SEGMENT_GLOBAL;    return ESegment; }
    "group"              { brigId = Brig::BRIG_SEGMENT_GROUP;     return ESegment; }
    "private"            { brigId = Brig::BRIG_SEGMENT_PRIVATE;   return ESegment; }
    "kernarg"            { brigId = Brig::BRIG_SEGMENT_KERNARG;   return ESegment; }
    "readonly"           { brigId = Brig::BRIG_SEGMENT_READONLY;  return ESegment; }
    "spill"              { brigId = Brig::BRIG_SEGMENT_SPILL;     return ESegment; }
    "arg"                { brigId = Brig::BRIG_SEGMENT_ARG;       return ESegment; }
    "flat"               { brigId = Brig::BRIG_SEGMENT_FLAT;      return ESegment; }

    "extern"             { brigId = Brig::BRIG_LINKAGE_EXTERN;    return EAttribute; }
    "static"             { brigId = Brig::BRIG_LINKAGE_STATIC;    return EAttribute; }

    "_u8x4"              { brigId = Brig::BRIG_TYPE_U8X4;  return EPackedLiteral; }
    "_s8x4"              { brigId = Brig::BRIG_TYPE_S8X4;  return EPackedLiteral; }
    "_u8x8"              { brigId = Brig::BRIG_TYPE_U8X8;  return EPackedLiteral; }
    "_s8x8"              { brigId = Brig::BRIG_TYPE_S8X8;  return EPackedLiteral; }
    "_u8x16"             { brigId = Brig::BRIG_TYPE_U8X16; return EPackedLiteral; }
    "_s8x16"             { brigId = Brig::BRIG_TYPE_S8X16; return EPackedLiteral; }
    "_u16x2"             { brigId = Brig::BRIG_TYPE_U16X2; return EPackedLiteral; }
    "_s16x2"             { brigId = Brig::BRIG_TYPE_S16X2; return EPackedLiteral; }
    "_f16x2"             { brigId = Brig::BRIG_TYPE_F16X2; return EPackedLiteral; }
    "_u16x4"             { brigId = Brig::BRIG_TYPE_U16X4; return EPackedLiteral; }
    "_s16x4"             { brigId = Brig::BRIG_TYPE_S16X4; return EPackedLiteral; }
    "_f16x4"             { brigId = Brig::BRIG_TYPE_F16X4; return EPackedLiteral; }
    "_u16x8"             { brigId = Brig::BRIG_TYPE_U16X8; return EPackedLiteral; }
    "_s16x8"             { brigId = Brig::BRIG_TYPE_S16X8; return EPackedLiteral; }
    "_f16x8"             { brigId = Brig::BRIG_TYPE_F16X8; return EPackedLiteral; }
    "_u32x2"             { brigId = Brig::BRIG_TYPE_U32X2; return EPackedLiteral; }
    "_s32x2"             { brigId = Brig::BRIG_TYPE_S32X2; return EPackedLiteral; }
    "_f32x2"             { brigId = Brig::BRIG_TYPE_F32X2; return EPackedLiteral; }
    "_u32x4"             { brigId = Brig::BRIG_TYPE_U32X4; return EPackedLiteral; }
    "_s32x4"             { brigId = Brig::BRIG_TYPE_S32X4; return EPackedLiteral; }
    "_f32x4"             { brigId = Brig::BRIG_TYPE_F32X4; return EPackedLiteral; }
    "_u64x2"             { brigId = Brig::BRIG_TYPE_U64X2; return EPackedLiteral; }
    "_s64x2"             { brigId = Brig::BRIG_TYPE_S64X2; return EPackedLiteral; }
    "_f64x2"             { brigId = Brig::BRIG_TYPE_F64X2; return EPackedLiteral; }

    "_rwimg"             { brigId = Brig::BRIG_TYPE_RWIMG; return EKWRWImg; }
    "_roimg"             { brigId = Brig::BRIG_TYPE_ROIMG; return EKWROImg; }
    "_woimg"             { brigId = Brig::BRIG_TYPE_WOIMG; return EKWWOImg; }
    "_samp"              { brigId = Brig::BRIG_TYPE_SAMP;  return EKWSamp; }

@print $scanner{EControl}

@print $scanner{EImageFormat}

@print $scanner{EImageOrder}

@print $scanner{EImageGeometry}

@print $scanner{ESamplerAddressingMode}

@print $scanner{ESamplerCoord}

@print $scanner{Instructions}

@print $scanner{ETargetMachine}

@print $scanner{ETargetProfile}

    "@" ID               { return ELabel;    }
    "&" ID               { return EIDStatic; }
    "%" ID               { return EIDLocal;  }
    "$" [csdq] DECIMAL   { return ERegister; }

    DECIMAL              { return EDecimalNumber; }
    OCTAL                { return EOctalNumber; }
    HEX                  { return EHexNumber; }

    FLOAT [hH]           { return EHlfNumber; }
    FLOAT [fF]           { return ESglNumber; }
    FLOAT [dD]?          { return EDblNumber; }

    HLFHEX               { return EHlfHexNumber; }
    SGLHEX               { return ESglHexNumber; }
    DBLHEX               { return EDblHexNumber; }

    C99FLT [hH]          { return EHlfC99Number; }
    C99FLT [fF]          { return ESglC99Number; }
    C99FLT [lL]?         { return EDblC99Number; }

    "\000"               { --curPos; return EEndOfSource; }

    ""                   { syntaxError(curPos, "Syntax error"); }
*/
}

void Scanner::skipWhitespaces(Scanner::Token& t)
{
    const char *curPos = t.m_text.begin;
    while(true) {
        const char *const prevPos = curPos;
        const char *marker;
/*!re2c
        re2c:indent:string  = "        ";
        SPACE           { continue; }
        NL              { nextLine(curPos); continue; }
        "/" "/"         { curPos = skipOneLinearComment(curPos, t); continue; }
        "/" "*"         { curPos = skipMultilineComment(curPos, t); continue; }
        "\000"          { curPos = prevPos; break; }
        ""              { break; }
*/
    }
    t.m_text.begin = t.m_text.end = curPos;
}

const char* Scanner::skipOneLinearComment(const char* from, Scanner::Token& t)
{
    const char *curPos = from;
    while(true) {
        const char *const prevPos = curPos;
/*!re2c
        re2c:indent:string = "        ";
        NL | "\000" { curPos = prevPos; t.appendComment(from, prevPos); break; }
        ANY         { continue; }
*/
    };
    return curPos;
}

const char* Scanner::skipMultilineComment(const char* from, Scanner::Token& t)
{
    const char *start = from;
    const char *curPos = from;

    while(true) {
        const char *const prevPos = curPos;
/*!re2c
        re2c:indent:string = "        ";
        NL       { t.appendComment(start, prevPos);
                   nextLine(curPos);
                   start = curPos;
                   continue; }
        "*" "/"  { t.appendComment(start, prevPos);
                   break; }
        "\000"   { curPos = prevPos; syntaxError(curPos, "Premature end of comment"); }
        ANY      { continue; }
*/
    };
    return curPos;
}

} // end namespace
