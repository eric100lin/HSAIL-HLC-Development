
#include "HSAILValidatorBase.h"
#include "HSAILTestGenDump.h"
#include "HSAILInstProps.h"

#include <sstream>
#include <string>
#include <iostream>

using std::string;
using std::ostringstream;

using namespace Brig;
using namespace HSAIL_ASM;
using namespace HSAIL_PROPS;

namespace TESTGEN {

//==============================================================================
//==============================================================================
//==============================================================================

static void dumpProp(string propName, string propVal)
{
    const char* fill = "          ";
    if (propName.length() < strlen(fill)) propName += (fill + propName.length());
    std::cerr << propName << "= " << propVal << "\n";
}

static void dumpProp(unsigned propId, string propVal)
{
    dumpProp(PropValidator::prop2key(propId), propVal);
}

//==============================================================================
//==============================================================================
//==============================================================================

static string getOperandName(unsigned idx)
{
    ostringstream s;
    s << "operand " << idx;
    return s.str();
}

static string operandImmed2str(OperandImmed o)   
{ 
    ostringstream s; 
    s << "IMM(" << (unsigned)o.bytes(0); 
    for (unsigned i = 1; i < o.byteCount(); ++i) 
    {
        s << ", " << (unsigned)o.bytes(i);  s << ")"; 
    }
    return s.str(); 
} 

static string operandVector2str(OperandVector o) 
{ 
    ostringstream s; 
    
    s << "("; 
    for (unsigned i = 0; i < o.elementCount(); ++i) 
    { 
        if (i > 0) s << ", "; 
        if      (OperandReg r = o.operand(i))     s << r.reg(); 
        else if (OperandImmed imm = o.operand(i)) s << operandImmed2str(imm);
        else                                      s << "*UNKNOWN*";
    } 
    s << ")"; 
    
    return s.str();
}

static string operandAddress2str(OperandAddress o) 
{
    ostringstream s;

    if (o.symbol())                                  s << "[" << o.symbol().name() << "]"; 
    if (o.reg())                                     s << "[" << o.reg()           << "]"; 
    if (o.offset() != 0 || !(o.symbol() || o.reg())) s << "[" << o.offset()        << "]"; 
    
    return s.str();
}

template <class T>
static string operandList2str(T o) 
{
    ostringstream s;

    s << "("; 
    for (unsigned i = 0; i < o.elementCount(); ++i)
    {
        s << (i > 0? ", " : "") << getName(o.elements(i)); 
    }
    s << ")";

    return s.str();
}

static void dumpOperand(unsigned idx, Operand opr)
{
    ostringstream s;

    if      (!opr)                            { s << "NULL";  }
    else if (OperandReg              o = opr) { s << o.reg(); }
    else if (OperandVector           o = opr) { s << operandVector2str(o); }
    else if (OperandAddress          o = opr) { s << operandAddress2str(o); } 
    else if (OperandWavesize         o = opr) { s << "wavesize"; }
    else if (OperandLabelRef         o = opr) { s << DirectiveLabel(o.ref()).name(); }
    else if (OperandFunctionRef      o = opr) { s << DirectiveFunction(o.ref()).name(); }
    else if (OperandSignatureRef     o = opr) { s << DirectiveSignature(o.ref()).name(); }
    else if (OperandFbarrierRef      o = opr) { s << DirectiveFbarrier(o.ref()).name(); }
    else if (OperandLabelTargetsRef  o = opr) { s << DirectiveLabelTargets(o.ref()).name(); }
    else if (OperandLabelVariableRef o = opr) { s << DirectiveVariable(o.ref()).name(); }
    else if (OperandArgumentList     o = opr) { s << operandList2str(o); }
    else if (OperandFunctionList     o = opr) { s << operandList2str(o); }
    else if (OperandImmed            o = opr) { s << operandImmed2str(o); }
    else                                      { s << "*UNKNOWN*, kind = " << opr.kind(); }

    dumpProp(getOperandName(idx), s.str());
}

static void visitProp(Inst inst, unsigned propId, unsigned propVal)
{
    if (propId == PROP_EQUIVCLASS)
    {
        ostringstream s;
        s << propVal;
        dumpProp(propId, s.str());
    }
    else
    {
        dumpProp(propId, PropValidator::val2str(propId, propVal));
    }
}

//==========================================================================
//==========================================================================
//==========================================================================
// Dumping test properties (autogenerated)

#include "HSAILBrigPropsVisitor_gen.hpp"

//==============================================================================
//==============================================================================
//==============================================================================

void dumpTestInst(Inst inst)
{
    std::cerr << "==========================================\n";

    visitBrigProps(inst);

    for (unsigned i = 0; i < 5; ++i) dumpOperand(i, inst.operand(i));
}

}; // namespace TESTGEN
